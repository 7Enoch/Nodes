###### 代码路径C:\Users\G\Desktop\学习\算法+数据结构\源代码\算法\算法学习

# 排序(排序)

## 冒泡排序

![image-20220325220358639](../../assets/算法/image-20220325220358639.png)





轮（i=9-1)：外层循环

比较次数（j=9-1-i）：内层循环

```c
//若存在一个数组arr[n]，里面存在若干数字，按照升序排列并打印
//思路分析如上图
//定义一个i，j控制内外层循环
int i,j,temp;
for(i=0;i<n-1;i++){
    //轮数 如图中的横排列
    for(j=0;j<n-1-i;j++){
    //每轮中的次数
        if(arr[j]>arr[j+1]){
            temp=arr[j];
            arr[j]=arr[j+1]；
            arr[j+1]=temp;
        }
   //判断并交换
    }  
}
```

```c
//示例：将数组{4，2，8，0，5，7，1，3，9}进行升序（小到大）排列 
#include <stdio.h>
main(){
	int arr[9]={4,2,3,5,7,0,1,3,9};
	int i,j;
	int temp=0; 
	
	for(i=0;i<9-1;i++)//外层循环（比较了几轮） 
	{
		for(j=0;j<9-1-i;j++)//内层循环(比较了几次) 
		{
			if(arr[j]>arr[j+1])//比较前者跟后者的的大小关系 
			{
				temp=arr[j];
				arr[j]=arr[j+1];
				arr[j+1]=temp;
			}
		}
	}
for(i=0;i<9;i++)
printf("arr[%d]=%d\n",i,arr[i]);

} 
```

## 选择排序（demo3）

```
思路:

数组a[N]

0 —— N-1长度的数组中寻找最小的数，让它与a[0]交换，然后忽略a[0]位置，从a[1]

1 —— N-1长度中寻找最小的数，让它与a[1]交换，然后忽略a[1]位置以此类推。
```



```java
if(arr == null || arr.length<2){
        return;
       }//考虑边界条件
```

```JAVA
int n = arr.length;
//获取数组长度
```

```java
分析：我们需要的范围如下
       //0 —— n-1
       //1 —— n-1
       //2 —— n-1
    所以需要一个循环来界定范围，如下
      for(int i = 0;i < n;i++){
          
      }
//i —— n-1 这个for界定左侧范围
```

```java
 int minIndex = i;//设置初始位置
```

```java
 for(int j = i+1;j < n ;j++){
            minIndex = arr[j] < arr[minIndex] ? j : minIndex;
            //如果后者比前者小则将minIndex更新为后面的位置，否则不变
        }//获取最小值位置
```

```Java
 	    int cur = arr[minIndex]; 
        arr[minIndex] = arr[i];
        arr[i] = cur;
//获取到位置后即可交换位置
```

## 插入排序（demo4）

```
思路:
一个数组arr{9,8,6,4,10,23,1,0,7}
让0-0位置有序 0位置位9已经有序
让0-1位置有序 0-1位置（9，8）arr[1]<arr[0]所以交换位置 数组变为arr{8,9,6,4,10,23,1,0,7}
让0-2位置有序 0-2位置（9，8，6）arr[2]<arr[1]所以交换位置 数组变为arr{8,6,9,4,10,23,1,0,7} arr[1]<arr[0]所以交换位置 数组变为arr{6,8,9,4,10,23,1,0,7}
以此类推
```

 	

# 数字处理(杂)

## 素数判断

```c
         int x;
		int i = 0;
	for(i=2;i<x;i++){	
 //执行到i=x-1的时候，依然不能整除，然后i++到x，跳出循环进行下一步if判断
 		if(x%i==0){
		break;
                   }
	                }
 //x是待确认数，for循环将i自增，  如果i在自增的时候把x整除了//（1.如果不是素数，i在增加的中途就会跳出循环，否则一直会到相等才会跳出循环）  ，跳出循环
 	if(x==i){
 	printf("是素数");
	  }
	  else{
  		printf("不是素数"); 
   	  }
//跳出循环的后的if判断x与i的值，印证1.



```

## 数字分解

将数字的每一位数分解出来
分析：
1.若一个数x是三位数，那么第一位数就是x/100，第二位就是x%100/10 (x/10%10)，第三位就是x%10/1
2.若一个数y是四位数，那么第一个位数就是x/1000,第二位就是x%1000/100(x/100%10),第三位就是x%100/10,第四位就是x%10
 总结：一个a位数的数字n，最高位都是：n/10^a-1,往后一位的数为n%10^a-1/10^a-2,往后两位是n%10^a-2/10^a-3,以此类推，无论多少位的数字，个位都是n%10;

### 数字分解应用

```c
//输入mn（m<n）求出m到n所有素数的和，并调用isprime（x）来判断x是不是素数 
//输入一个三位数，分解个十百位，并将个十百的 和跟积 分两行打印
#include <stdio.h>
main() {
	int n;
	int sum;
	int prd;
	scanf("%d",&n);
	if(n>=100&&n<=900){
		
        int a=n/100;
		int b=n%100/10;
		int c=n%10;
		//数字分解主体
        sum=a+b+c;
	    prd=a*b*c;
		
	}
	printf("%d %d",sum,prd);
}
```

# 进制转换(杂)

## 整数转二进制32位输出（demo1）

基础知识：

1. ​       整型数字在计算机中都是32位储存
2. ​       1<<31的含义是整数1左移31位
3. ​       32位最高位为符号位，0代表正，1代表负，负数计算方式为，最高位不管，其他位取反并加1
3. <<或>>(带符号移动)移动位置后用符号位（0正数1负数）补原本位置  
3. <<<或>>>（不带符号移动） 0补最高位
3. c = 5;-5=(~c+1);负数等于对应正数取反加一

左移一位 等同与 乘以2

分析：例如数字4

二进制为000......00100，建立一个32次的循环，每次建立一个32位中只有一位是1的数字，来&4的二进制的每一位，若4的那一位是与这个建立的数字的那一位都是1则为1，否则为0

代码：

```java
public 	class code_jingzhi{
    
int num;
public static void print(int num){
for(int i=31;i>=0;i--){
    //建立一个32次的循环
 System.out.print((num & (1<<i))== 0 ? "0" : "1");
    //1<<i 每次建立一个32位中只有一位是1的数字
}
System.out.print();
}
public static void main(String args[]){
    int num=4;
    print(num);
}
}
```

## 输入n 打印结果1！+2！+3！+......+n！（demo2）

### 思路

1. ```
   1!
   2!=1*2
   3!=1*2*3
   .
   .
   n!=1*2*3.....*n
   每次累加
   ```

2. ```
   1！
   2!=1!*2
   3!=2!*3
   .
   .
   n!=(n-1)!*n
   ```

    

# 基本算法思想(基本算法思想)

## 贪心算法

每一次都进行最优选

基本引入：海盗船问题（demo1)

有一个商船，上面有一些货物，它们的重量不一样但是价值一样，现在被海盗船打劫，海盗船有承重限制，怎么样让海盗船能拿走最多价值的货物

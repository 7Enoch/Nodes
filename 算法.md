# 排序(排序)

## 冒泡排序

轮（i=9-1)：外层循环

比较次数（j=9-1-i）：内层循环

```c
//若存在一个数组arr[n]，里面存在若干数字，按照升序排列并打印
//思路分析如上图
//定义一个i，j控制内外层循环
int i,j,temp;
for(i=0;i<n-1;i++){
    //轮数 如图中的横排列
    for(j=0;j<n-1-i;j++){
    //每轮中的次数
        if(arr[j]>arr[j+1]){
            temp=arr[j];
            arr[j]=arr[j+1]; 
            arr[j+1]=temp;
        }
   //判断并交换
    }  
}
```

```c
//示例：将数组{4，2，8，0，5，7，1，3，9}进行升序（小到大）排列 
#include <stdio.h>
main(){
	int arr[9]={4,2,3,5,7,0,1,3,9};
	int i,j;
	int temp=0; 
	
	for(i=0;i<9-1;i++)//外层循环（比较了几轮） 
	{
		for(j=0;j<9-1-i;j++)//内层循环(比较了几次) 
		{
			if(arr[j]>arr[j+1])//比较前者跟后者的大小关系 
			{
				temp=arr[j];
				arr[j]=arr[j+1];
				arr[j+1]=temp;
			}
		}
	}
for(i=0;i<9;i++)
printf("arr[%d]=%d\n",i,arr[i]);

} 
```

## 选择排序

```
路:

数组a[N]

0 —— N-1长度的数组中寻找最小的数，让它与a[0]交换，然后忽略a[0]位置，从a[1]

1 —— N-1长度中寻找最小的数，让它与a[1]交换，然后忽略a[1]位置以此类推。
```



```java
if(arr == null || arr.length<2){
        return;
       }//考虑边界条件
```

```JAVA
int n = arr.length;
//获取数组长度
```

```java
分析：我们需要的范围如下
       //0 —— n-1
       //1 —— n-1
       //2 —— n-1
    所以需要一个循环来界定范围，如下
      for(int i = 0;i < n;i++){
          
      }
//i —— n-1 这个for界定左侧范围
```

```java
 int minIndex = i;//设置初始位置
```

```java
 for(int j = i+1;j < n ;j++){
            minIndex = arr[j] < arr[minIndex] ? j : minIndex;
            //如果后者比前者小则将minIndex更新为后面的位置，否则不变
        }//获取最小值位置
```

```Java
 	    int cur = arr[minIndex]; 
        arr[minIndex] = arr[i];
        arr[i] = cur;
//获取到位置后即可交换位置
```

## 插入排序

```
思路:
一个数组arr{9,8,6,4,10,23,1,0,7}
让0-0位置有序 0位置位9已经有序
让0-1位置有序 0-1位置（9，8）arr[1]<arr[0]所以交换位置 数组变为arr{8,9,6,4,10,23,1,0,7}
让0-2位置有序 0-2位置（9，8，6）arr[2]<arr[1]所以交换位置 数组变为arr{8,6,9,4,10,23,1,0,7} arr[1]<arr[0]所以交换位置 数组变为arr{6,8,9,4,10,23,1,0,7}
以此类推
```

 	

# 数字处理

## 素数判断

```c
         int x;
		int i = 0;
	for(i=2;i<x;i++){	
 //执行到i=x-1的时候，依然不能整除，然后i++到x，跳出循环进行下一步if判断
 		if(x%i==0){
		break;
                   }
	                }
 //x是待确认数，for循环将i自增，  如果i在自增的时候把x整除了//（1.如果不是素数，i在增加的中途就会跳出循环，否则一直会到相等才会跳出循环）  ，跳出循环
 	if(x==i){
 	printf("是素数");
	  }
	  else{
  		printf("不是素数"); 
   	  }
//跳出循环的后的if判断x与i的值，印证1.



```

# 进制转换

## 整数转二进制32位输出

基础知识：

1. ​       整型数字在计算机中都是32位储存
2. ​       1<<31的含义是整数1左移31位
3. ​       32位最高位为符号位，0代表正，1代表负，负数计算方式为，最高位不管，其他位取反并加1
3. <<或>>(带符号移动)移动位置后用符号位（0正数1负数）补原本位置  
3. <<<或>>>（不带符号移动） 0补最高位
3. c = 5;-5=(~c+1);负数等于对应正数取反加一

左移一位 等同与 乘以2

分析：例如数字4

二进制为000......00100，建立一个32次的循环，每次建立一个32位中只有一位是1的数字，来&4的二进制的每一位，若4的那一位是与这个建立的数字的那一位都是1则为1，否则为0

代码：

```java
public 	class code_jingzhi{
    
int num;
public static void print(int num){
for(int i=31;i>=0;i--){
    //建立一个32次的循环
 System.out.print((num & (1<<i))== 0 ? "0" : "1");
    //1<<i 每次建立一个32位中只有一位是1的数字
}
System.out.print();
}
public static void main(String args[]){
    int num=4;
    print(num);
}
}
```

# 算法思想(基本算法思想)

## 贪心算法

每一次都进行最优选

基本引入：海盗船问题（demo1)

有一个商船，上面有一些货物，它们的重量不一样但是价值一样，现在被海盗船打劫，海盗船有承重限制，怎么样让海盗船能拿走最多价值的货物

## 二分法

#### 寻找num

从中间开始寻找数num，小于num的全部排除，在剩下的数里面再选中间...

找到num返回t

找完所有数都找不到就返回f

#### 寻找>=num的最左位置

[0,1,1,1,1,2,2,2,3,3,4,4,5,5,,6,6,6,6,7,7,8]

比如寻找num>=2的最左值

#### 返回局部最小

前提：相邻不相等，如果数组只有一个数则返回当前数索引 

0位置到1位置 arr[0]<arr[1] 0位置就是最小位置 

n-2位置到n-1位置 arr[n-2]>arr[n-1] n-1就是最小位置

i-1位置到i位置到i+1位置 i-1>i<i-2 i就是最小位置



arr[0]>arr[1] && arr[n-2]<arr[n-1]

1-n-2必存在局部最小值

（函数左导数<0 右导数>0则必存在导数=0即开口向上函数必存在最小值)

### 技巧：寻找中间数的时候 建议不要用(L+R)/2可能会溢出，建议使用L+(R-L)/2或者L+(R-L)>>1就不会溢出了

## 异或

![image-20230104211728805](../学习/assets/算法/image-20230104211728805.png)

就是相同为0 不同为1（二进制层面）

上面的N是一个十进制 展开每一位满足异或，即数字为本身

#### 不用额外变量交换数值

![image-20230104213859820](../学习/assets/算法/image-20230104213859820.png)

```java
a = a^b;
b = a^b;
a = a^b;
```

```
a^b^b ==a
b^a^a ==b
```

![image-20230104214544674](../学习/assets/算法/image-20230104214544674.png)

注意：两个相同数一定要在不同空间（数组）

## 位图

功能：记录在确定大小的数字集合中判断数字是否出现过

优点：极大的压缩空间

```java
定义一个int set = 0;
因为整数是32位2进制数（long是64位可以表示0-64的数）
所以可以用set来标记0-31出现的次数
节省空间
区别:
如果用集合直接储存0-31的数字需要32*4个byte
而使用一个set来储存0-31的数字只需要4个byte
具体使用:
set展开为32个0二进制
0-31的数字，出现了就将set对应的0位置标记成1位置
拓展:
若要表示0-2^n个数字出现是否
可以定义一个int[] set数组，数组长度为2^n/32(因为数组中一个位置就能表示32个数字)
原本储存2^n个数需要2^n*4个byte
现在只需要2^n/32*4个byte
```



## 位运算

一个数num%64与num&63等价

```java
举例%:
若这个数num展开为
00...00110101101010101011101 num
00...00000000000000001000000 64
上面两个数%就得到
00...00000000000000000011101 result
因为第7位为1是64
对于num第七位往上的所有数字都是64的倍数
所以当他们%了后 比第7位高的数字（包含第七位）都变为0
结果就是7位往下的其余二进制不变
===============================================
举例&:(&有0就0)
依然拿上面举例子
00...00110101101010101011101 num
00...00000000000000000111111 63
所以结果为
00...00000000000000000011101 result
与上面吻合
```

### 位运算实现加减乘除

两个数相加 就等于两个数的二进制无进位相加 加上 两个数的进位信息

无进位相加 等于两个数 异或^

进位信息等于两个数 与& 左移一位

一直套娃 直到 没有进位信息 无进位相加的结果就是两数相加的最后结果
